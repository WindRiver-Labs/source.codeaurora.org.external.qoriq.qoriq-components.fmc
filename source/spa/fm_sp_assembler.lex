/* =====================================================================
 *
 *  Copyright 2009,2010, Freescale Semiconductor, Inc., All Rights Reserved. 
 *
 *  This file contains copyrighted material. Use of this file is restricted
 *  by the provisions of a Freescale Software License Agreement, which has
 *  either accompanied the delivery of this software in shrink wrap
 *  form or been expressly executed between the parties.
 *
 *  Packet Engine Soft Parser Lexical Analyzer.
 *
 * --------------------------------------------------------------------------*/

%{
#include <string.h>
#include <stdlib.h>
#include <errno.h>

#include "fm_sp_private.h"
#include "fm_sp_assembler.tab.h"

#ifdef _MSC_VER
#pragma warning(disable : 4996)
#pragma warning(disable : 4003)
#pragma warning(disable : 4018)
#endif

#define YY_DECL int _fmsp_assembler_yylex(void                             *lval_p, \
                                          _fmsp_assembler_parser_context_t *context_p)

#define _FMSP_MALLOC_FAIL_EXIT_PARSE                                  \
   context_p->assemble_failed = true;                                 \
   context_p->assemble_msg_composition_error = fmsp_malloc_failure_e; \
   yyterminate();

/* Deal with warnings generated by flex code */

#if defined(PLATFORM_ppc_750)
#define size_t int
#endif

int   _fmsp_assembler_yyget_lineno  (void);
FILE *_fmsp_assembler_yyget_in      (void);
FILE *_fmsp_assembler_yyget_out     (void);
int   _fmsp_assembler_yyget_leng    (void);
char *_fmsp_assembler_yyget_text    (void);
void  _fmsp_assembler_yyset_lineno  (int   line_number );
void  _fmsp_assembler_yyset_in      (FILE *in_str );
void  _fmsp_assembler_yyset_out     (FILE *out_str );
int   _fmsp_assembler_yyget_debug   (void);
void  _fmsp_assembler_yyset_debug   (int   bdebug );
int   _fmsp_assembler_yylex_destroy (void);

%}

%option noyywrap

HEX_WORD  0x[0-9a-fA-F]{4}
HEX_VALUE 0x[0-9a-fA-F]+
DEC_VALUE [0-9]+
ONESCOMP  WR0[ ]*=[ ]*ONESCOMP[ ]*"("[ ]*WR0[ ]*,[ ]*WR1[ ]*")"

%%
#.*$           /* Ignore comments */

\r\n|\r|\n     {
                  context_p->line_number++;
                  //return END_OF_LINE;
               }

^[ \t]*$       {
                  //return BLANK_LINE;
               }

^!             {
                  return START_RAW_INSTRUCTION;
               }

{ONESCOMP}     {
                  return ONESCOMP;
               }

AND            {
                  return AND;
               }

OR             {
                  return OR;
               }

XOR            {
                  return XOR;
               }

\+=            {
                  return INCREMENT;
               }

\|=            {
                  return SET_BITS;
               }

\<\<=          {
                  return CONCAT;
               }

=              {
                  return ASSIGN;
               }

\<\<           {
                  return SHIFT_LEFT;
               }

\>\>           {
                  return SHIFT_RIGHT;
               }

{HEX_WORD}     {
                  ((YYSTYPE *)lval_p)->string = strdup(_fmsp_assembler_yytext);
                  return HEX_WORD;
               }

{HEX_VALUE}    {
                  ((YYSTYPE *)lval_p)->string = strdup(_fmsp_assembler_yytext);
                  return HEX_VALUE;
               }

{DEC_VALUE}    {
                  char *tmp_str_p = strdup(_fmsp_assembler_yytext);
                  errno = 0;
                  ((YYSTYPE *)lval_p)->integer = (int) strtol(_fmsp_assembler_yytext,
                                                              (char **)NULL,
                                                              10);
                  if (errno != 0)
                  {
                     context_p->assemble_failed = true;
                     yyterminate();
                  }

                  free (tmp_str_p);

                  return DEC_VALUE;
               }

RA"["          {
                  return START_RESULT_ARRAY;
               }

PA"["          {
                  return START_PARAMETER_ARRAY;
               }

FW"["          {
                  return START_FRAME_WINDOW;
               }

"]"            {
                  return RIGHT_BRACKET;
               }

".."           {
                  return BRIDGE;
               }

IF             {
                  return IF;
               }

HXS            {
                  return HXS;
               }

"|"            {
                  return PIPE;
               }

"&"            {
                  return AMPERSAND;
               }

"?"            {
                  return QUESTION;
               }

:              {
                  return COLON;
               }

"=="           {
                  return EQUAL;
               }

"!="           {
                  return NOT_EQUAL;
               }

\>             {
                  return GREATER_THAN;
               }

\<             {
                  return LESS_THAN;
               }

\>=            {
                  return GREATER_THAN_EQUAL;
               }

\<=            {
                  return LESS_THAN_EQUAL;
               }

\+             {
                  return PLUS;
               }

\-             {
                  return MINUS;
               }

LCV            {
                  return LCV;
               }

JMP            {
                  return JMP;
               }

NOP            {
                  return NOP;
               }

HB             {
                  return HEADER_BASE;
               }

WO             {
                  return WINDOW_OFFSET;
               }

CLR            {
                  return CLEAR;
               }

CLM            {
                  return CONFIRM_LAYER_MASK;
               }

ETH_HXS        {
                  return ETH_HXS;
               }

IPV4_HXS       {
                  return IPV4_HXS;
               }

IPV6_HXS       {
                  return IPV6_HXS;
               }

OTH_L3_HXS     {
                  return OTH_L3_HXS;
               }

TCP_HXS        {
                  return TCP_HXS;
               }

UDP_HXS        {
                  return UDP_HXS;
               }

OTH_L4_HXS     {
                  return OTH_L4_HXS;
               }

RETURN_HXS     {
                  return RETURN_HXS;
               }

NXT_ETH_TYPE   {
                  return NXT_ETH_TYPE;
               }

NXT_IP_PROTO   {
                  return NXT_IP_PROTO;
               }

END_PARSE      {
                  return END_PARSE;
               }

WR0            {
                  return WR0;
               }

WR1            {
                  return WR1;
               }

uint6_t        {
                  return UINT6_TYPE;
               }

PA_index_t     {
                  return UINT6_TYPE;
               }

uint7_t        {
                  return UINT7_TYPE;
               }

WR_shift_t     {
                  return UINT7_TYPE;
               }

uint8_t        {
                  return UINT8_TYPE;
               }

uint16_t       {
                  return UINT16_TYPE;
               }

uint32_t       {
                  return UINT32_TYPE;
               }

uint48_t       {
                  return UINT48_TYPE;
               }

uint64_t       {
                  return UINT64_TYPE;
               }

"("            {
                  return OPEN_PAREN;
               }

")"            {
                  return CLOSE_PAREN;
               }

","            {
                  return COMMA;
               }

[a-zA-Z][a-zA-Z0-9_]* {
                       ((YYSTYPE *)lval_p)->string = strdup(_fmsp_assembler_yytext);

                       if (((YYSTYPE *)lval_p)->string == NULL)
                       {
                          _FMSP_MALLOC_FAIL_EXIT_PARSE
                       }
     
                       return ALPHA_NUMERIC_WORD;
                    }

.              {
                 /* Eat up other junk */
               }

<<EOF>>        {
                  yyterminate();
               }
%%

/* Cleanup */
void _fmsp_assembler_lexical_analyzer_cleanup(void)
{
   _fmsp_assembler_yy_delete_buffer( YY_CURRENT_BUFFER );
}
